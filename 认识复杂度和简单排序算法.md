# 认识复杂度和简单排序算法

## 几种位运算

1. ^/caret；异或运算/xor；无进位相加/No carry addition：两者不相等则为1，两者相等则为0

   满足交换律和结合律

   **交换a和b的值：**

   ```java
   a = a ^ b;
   b = a ^ b;
   a = a ^ b;
   ```

   用到此运算的题：

   - 一个数字出现了奇数次，其他数字出现了偶数次
   - 两个数字出现了奇数次，其他数字出现了偶数次

2. ~/tilde；取反：二进制数字取反

3. **需要提取出一个数二进制位上最右侧的1：**

   ```java
   int rightOne = num & (~num + 1);
   ```

## 几种简单排序算法

1. 冒泡排序
2. 选择排序
3. 插入排序

## 二分法的应用场景

1. 在一个有序数组中，找某一个数是否存在
2. 在一个有序数组中，找>=某个数最左侧的位置
3. 局部最小值问题

## 对数器

用来测试写出的算法是否正确

对于一个问题准备两个算法，一个A（需要测试的），一个B（容易想到的，尽量正确的）
生成很多个随机数组，分别代入A和B，判断两个方法的out是否相等，测他个五十万次，就能说A是正确的。

## 认识递归（求一个数组上的最大值）

### 求中点

$\frac { L + R } { 2 }$ 其实并不是很完美的，如果 $L+R$ 溢出了，那就有问题。

那更优秀的写法是：$L + \frac { R - L } { 2 }$ 
或者更简化的写法：$L+(R-L)>>1$ 右移一位就相当于/2（更快）

### 递归的时间复杂度估计

master公式：$\left. \begin{array}  { l  }  { T ( N ) = a \times T ( \frac { N } { b } ) } { + O ( N ^ { d } ) } \end{array} \right.$
第一项的a指的是子问题执行了多少次，第一项的T指的是子问题，第二项指的是除了子问题之外的处理时间

要符合的话需要子问题规模相同

**符合master公式的递归问题，其时间复杂度如下**
$$
\log _ { b } a \lt d : O(N^d) \\
\log _ { b } a \gt d : O(N ^ { \log _ { b } a }) \\
\log _ { b } a = d : O(N ^ { d } \times \log N)
$$
